use crate::lexer;
use crate::ast::{expr, stmt, decl, self};

grammar;

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        "auto" => lexer::Tok::Auto,
        "break" => lexer::Tok::Break,
        "case" => lexer::Tok::Case,
        "char" => lexer::Tok::Char,
        "const" => lexer::Tok::Const,
        "continue" => lexer::Tok::Continue,
        "default" => lexer::Tok::Default,
        "do" => lexer::Tok::Do,
        "double" => lexer::Tok::Double,
        "else" => lexer::Tok::Else,
        "enum" => lexer::Tok::Enum, 
        "extern" => lexer::Tok::Extern, 
        "float" => lexer::Tok::Float,  
        "for" => lexer::Tok::For, 
        "goto" => lexer::Tok::Goto, 
        "if" => lexer::Tok::If,
        "inline" => lexer::Tok::Inline, 
        "int" => lexer::Tok::Int, 
        "long" => lexer::Tok::Long, 
        "register" => lexer::Tok::Register, 
        "restrict" => lexer::Tok::Restrict, 
        "return" => lexer::Tok::Return,
        "short" => lexer::Tok::Short,  
        "signed" => lexer::Tok::Signed, 
        "sizeof" => lexer::Tok::Sizeof, 
        "static" => lexer::Tok::Static, 
        "struct" => lexer::Tok::Struct,
        "switch" => lexer::Tok::Switch, 
        "typedef" => lexer::Tok::Typedef, 
        "union" => lexer::Tok::Union, 
        "unsigned" => lexer::Tok::Unsigned, 
        "void" => lexer::Tok::Void,
        "volatile" => lexer::Tok::Volatile, 
        "while" => lexer::Tok::While,  
        "_Alignas" => lexer::Tok::Alignas,  
        "_Alignof" => lexer::Tok::Alignof, 
        "_Atomic" => lexer::Tok::Atomic,
        "_Bool" => lexer::Tok::Bool, 
        "_Complex" => lexer::Tok::Complex, 
        "_Generic" => lexer::Tok::Generic, 
        "_Imaginary" => lexer::Tok::Imaginary, 
        "_Noreturn" => lexer::Tok::Noreturn, 
        "_Static_assert" => lexer::Tok::StaticAssert, 
        "_Thread_local" => lexer::Tok::ThreadLocal,

        TypedefName => lexer::Tok::TypedefName,
        Identifier => lexer::Tok::Identifier,
        Constant => lexer::Tok::Arrow,
        EnumerationConstant => lexer::Tok::Identifier,
        StringLiteral => lexer::Tok::StringLiteral,

        ")" => lexer::Tok::RightCurvedParenthesis,
        "(" => lexer::Tok::LeftCurvedParenthesis,
        "," => lexer::Tok::Comma,
        ":" => lexer::Tok::Colon,
        "[" => lexer::Tok::LeftSquareBracket,
        "]" => lexer::Tok::RightSquaredBracket,
        "." => lexer::Tok::Dot,
        "->" => lexer::Tok::Arrow,
        "++" => lexer::Tok::TwoPluses,
        "--" => lexer::Tok::TwoMinuses,
        "{" => lexer::Tok::LeftCurlyBrace,
        "}" => lexer::Tok::RightCurlyBrace,
        "&" => lexer::Tok::Ampersand,
        "*" => lexer::Tok::Star,
        "+" => lexer::Tok::Plus,
        "-" => lexer::Tok::Minus, 
        "~" => lexer::Tok::Wave,
        "!" => lexer::Tok::ExclamationMark,
        "/" => lexer::Tok::Slash,
        "%" => lexer::Tok::Percent,
        "<<" => lexer::Tok::TwoSmaller,
        ">>" => lexer::Tok::TwoLager,
        "<" => lexer::Tok::Smaller,
        ">" => lexer::Tok::Lager,
        "<=" => lexer::Tok::LeOrEq,
        ">=" => lexer::Tok::GeOrEq,
        "==" => lexer::Tok::Equal, 
        "!=" => lexer::Tok::NotEq,
        "^" => lexer::Tok::CheckMark,
        "|" => lexer::Tok::VerticalLine,
        "&&" => lexer::Tok::TwoAmpersand,
        "||" => lexer::Tok::TwoVerticalLine,
        "?" => lexer::Tok::QuestionMark,
        "=" => lexer::Tok::Asign,
        "*=" => lexer::Tok::StarAsign,
        "/=" => lexer::Tok::SlashAsign, 
        "%=" => lexer::Tok::S1,
        "+=" => lexer::Tok::S2,
        "-=" => lexer::Tok::S3,
        "<<=" => lexer::Tok::S4,
        ">>=" => lexer::Tok::S5,
        "&=" => lexer::Tok::AmpersandAsign,
        "^=" => lexer::Tok::CheckMarkAsign,
        "|=" => lexer::Tok::VerticalAsign,
        ";" => lexer::Tok::Semicolon,
        "..." => lexer::Tok::ThreeDots,
    }
}

//////////////////////////////////////////////////
/// External definitions /////////////////////////
//////////////////////////////////////////////////

pub TranslationUnit: ast::Ast = <items: ExternalDeclaration*> => ast::Ast(items);

ExternalDeclaration: ast::ExternalDeclaration = {
    FunctionDefinition => ast::FunctionDefinition(<>),
    Declaration,
};

FunctionDefinition: ast::FunctionDefinition = {
    <specifiers: DeclarationSpecifiers> <declarator: Declarator> <declaration: DeclarationList?> <compound: CompoundStatement>
        => ast::FunctionDefinition{specifiers, declarator, declaration, compound}
};

DeclarationList = Declaration+;

//////////////////////////////////////////////////
/// Declarations /////////////////////////////////
//////////////////////////////////////////////////

Declaration: Box<decl::Decl> = {
    <dspec: DeclarationSpecifiers> <idec: InitDeclaratorList?> ";" 
        => decl::Decl::Other(decl::Other{specifiers: dspec, init_declarators: idec}),
    <sa: StaticAssertDeclaration>
        => decl::Decl::StaticAssert(sa),
};

DeclarationSpecifier: decl::DeclarationSpecifier = {
    <spec: StorageClassSpecifier>  
        => decl::DeclarationSpecifier::StorageClassSpecifier(spec),
    <spec: TypeSpecifier>
        => decl::DeclarationSpecifier::TypeSpecifier(spec), 
    <spec: TypeQualifier>
        => decl::DeclarationSpecifier::TypeQualifier(spec), 
    <spec: FunctionSpecifier>
        => decl::DeclarationSpecifier::FunctionSpecifier(spec), 
    <spec: AlignmentSpecifier>
        => decl::DeclarationSpecifier::AlignmentSpecifier(spec), 
};

DeclarationSpecifiers = DeclarationSpecifier+;

InitDeclaratorList = {
    InitDeclarator ("," InitDeclarator)*
};

InitDeclarator: decl::InitDeclarator = {
    <dec: Declarator> 
        => decl::InitDeclarator{declarator: dec, initializer: None},
    <dec: Declarator> "=" <ini: Initializer>
        => decl::InitDeclarator{declarator: dec, initializer: Some(ini)},
};

StorageClassSpecifier: decl::StorageClassSpecifier = {
    "typedef" => decl::StorageClassSpecifier::Typedef,
    "extern" => decl::StorageClassSpecifier::Extern,
    "static" => decl::StorageClassSpecifier::Static,
    "_Thread_local" => decl::StorageClassSpecifier::ThreadLocal,
    "auto" => decl::StorageClassSpecifier::Auto,
    "register" => decl::StorageClassSpecifier::Register,
};

TypeSpecifier: decl::TypeSpecifier = {
    "void" 
        => decl::TypeSpecifier::Void,
    "char" 
        => decl::TypeSpecifier::Char,
    "short" 
        => decl::TypeSpecifier::Short,
    "int" 
        => decl::TypeSpecifier::Int,
    "long" 
        => decl::TypeSpecifier::Long,
    "float" 
        => decl::TypeSpecifier::Float,
    "double" 
        => decl::TypeSpecifier::Double,
    "signed" 
        => decl::TypeSpecifier::Signed,
    "unsigned" 
        => decl::TypeSpecifier::Unsigned,
    "_Bool" 
        => decl::TypeSpecifier::Bool,
    "_Complex" 
        => decl::TypeSpecifier::Complex,
    <ats: AtomicTypeSpecifier> 
        => decl::TypeSpecifier::AtomicTypeSpecifier(ats),
    <sous: StructOrUnionSpecifier>
        => decl::TypeSpecifier::StructOrUnionSpecifier(sous), 
    EnumSpecifier 
        => decl::TypeSpecifier::EnumSpecifier(sous),
    <tdef: TypedefName> 
        => decl::TypeSpecifier::TypedefName(sous),
};

StructOrUnionSpecifier: decl::StructOrUnionSpecifier = {
    StructOrUnion Identifier? "{" StructDeclarationList "}"
    StructOrUnion Identifier
};

StructOrUnion: decl::ObjKind = {
    "struct" => decl::ObjKind::Struct,
    "union" => decl::ObjKind::Union,
};

StructDeclarationList = StructDeclaration+;

StructDeclaration: decl::StructDeclaration = {
    SpecifierQualifierList StructDeclaratorList? ";",
    StaticAssertDeclaration,
};

SpecifierQualifierList = 
    TypeSpecifier TypeQualifier
;

StructDeclaratorList = StructDeclarator ("," StructDeclarator)*;

StructDeclarator: decl::StructDeclarator = {
    Declarator,
    Declarator? ":" ConstantExpression,
}

EnumSpecifier = {
    "enum" Identifier? "{" EnumeratorList ","? "}"
    "enum" Identifier
};

EnumeratorList = 
    Enumerator ("," Enumerator)*
;

Enumerator =
    EnumerationConstant ("=" ConstantExpression)?
;

AtomicTypeSpecifier: decl::AtomicTypeSpecifier =
    "_Atomic" "(" <typename: TypeName> ")"
        => AtomicTypeSpecifier{typename}
;

TypeQualifier: decl::TypeQualifier = {
    "const" => decl::TypeQualifier::Const,
    "restrict" => decl::TypeQualifier::Restrict,
    "volatile" => decl::TypeQualifier::Volatile,
    "_Atomic" => decl::TypeQualifier::Atomic,
};

FunctionSpecifier: decl::FunctionSpecifier = {
    "inline" => decl::FunctionSpecifier::Inline,
    "_Noreturn" => decl::FunctionSpecifier::Noreturn,
};

AlignmentSpecifier = {
    "_Alignas" "(" TypeName ")"
    "_Alignas" "(" ConstantExpression ")"
}

Declarator =    
    Pointer? DirectDeclarator
;

DirectDeclarator = Identifier;

Pointer = ("*" TypeQualifierList?)+;
TypeQualifierList: Vec<TypeQualifier> = TypeQualifier+;

ParameterTypeList = {
    ParameterList
    ParameterList "," "..."
};

ParameterList = ParameterDeclaration ("," ParameterDeclaration)*;

ParameterDeclaration = {
    DeclarationSpecifiers Declarator
    DeclarationSpecifiers AbstractDeclarator?
};

IdentifierList = Identifier ("," Identifier)*;

TypeName = SpecifierQualifierList AbstractDeclarator?;

AbstractDeclarator: decl::AbstractDeclarator = {
    Pointer,
    Pointer? DirectAbstractDeclarator,
};

DirectAbstractDeclarator: decl::DirectAbstractDeclarator = {
    "(" AbstractDeclarator ")"
    DirectAbstractDeclarator? "[" TypeQualifierList? AssignmentExpression? "]"
    DirectAbstractDeclarator? "[" "static" TypeQualifierList? AssignmentExpression "]"
    DirectAbstractDeclarator? "[" TypeQualifierList "static" AssignmentExpression "]"
    DirectAbstractDeclarator? "[" "*" "]"
    DirectAbstractDeclarator? "(" ParameterTypeList? ")"
};

Initializer: decl::Initializer = {
    <ae: AssignmentExpression> => decl::Initializer::AssignmentExpression
    "{" <il: InitializerList> ","? "}" => decl::Initializer::InitializerList(il),
};

InitializerList: decl::InitializerList= 
    Designation? Initializer ("," Designation? Initializer)* 
        => todo!()
;

Designation: Vec<decl::Designator> = DesignatorList "=";

DesignatorList: Vec<decl::Designator> = Designator+;

Designator: decl::Designator = {
    "[" <expr: ConstantExpression> "]" => decl::Designator::Index(expr),
    "." <ident: Identifier> => decl::Designator::Dot(ident),
};

StaticAssertDeclaration: Box<decl::Decl> = 
    "_Static_assert" "(" <predicate: ConstantExpression> "," <message: StringLiteral> ")" ";"
        => Box::new(decl::Decl::StaticAssert(decl::StaticAssert{predicate, message}))
;


//////////////////////////////////////////////////
/// Expression ///////////////////////////////////
//////////////////////////////////////////////////

PrimaryExpression: Box<expr::Expression> = {
    Identifier,
        => Box::new(expr::Expression::Identifier(ident)),
    Constant,
    StringLiteral,
    "(" Expression ")",
    GenericSelection,
};

GenericSelection: Box<expr::Expression> = {
    "_Generic" "(" <expression: AssignmentExpression> "," <association_list: GenericAssocList> ")" 
        => Box::new(expr::Expression::GenericSelection(expr::GenericSelectionExpr{
            expression, association_list
        }))
};

GenericAssocList: Vec<expr::GenericAssociation> = { 
    GenericAssociation ("," GenericAssociation)* 
        => todo!()
};

GenericAssociation: expr::GenericAssociation = {
    TypeName ":" <expression: AssignmentExpression>
        => expr::GenericAssociation{expression},
    "default" ":" <expression: AssignmentExpression>
        => expr::GenericAssociation{expression},
};

PostfixExpression: Box<expr::Expression> = {
    PrimaryExpression,
    PostfixExpression "[" Expression "]" 
        => expr::TwoOperandsExpr::new_subscript(<>),
    PostfixExpression "(" ArgumentExpressionList? ")"
        => expr::CallExpr::new(<>),
    PostfixExpression "." Identifier
        => expr::TwoOperandsExpr::new_access(<>),
    PostfixExpression "->" Identifier
        => expr::TwoOperandsExpr::new_ptr_access(<>),
    PostfixExpression "++"
        => expr::OneOperandExpr::new_postincrement(<>),
    PostfixExpression "--"
        => expr::OneOperandExpr::new_postdecrement(<>),
    "(" TypeName ")" "{" InitializerList "}"
        => expr::CompoundLiteral::new(i),
    "(" TypeName ")" "{" <i: InitializerList> "," "}"
        => expr::CompoundLiteral::new(i),
};

ArgumentExpressionList: Box<expr::Expression> = {
    AssignmentExpression, <items: ("," AssignmentExpression)*>
        => todo!()
};

UnaryExpression: Box<expr::Expression> = {
    PostfixExpression,
    "++" UnaryExpression 
        => expr::OneOperandExpr::new_increment(<>),
    "--" UnaryExpression 
        => expr::OneOperandExpr::new_decrement(<>),
    UnaryOperator CastExpression,
    "sizeof" UnaryExpression 
        => expr::Sizeof::new(<>),
    "sizeof" "(" TypeName ")" 
        => expr::Sizeof::new(<>),
    "_Alignof" "(" TypeName ")" 
        => expr::AlignOf::new(<>),
};

UnaryOperator: expr::UnaryOp = {
    "&" => expr::UnaryOp::Address,
    "*" => expr::UnaryOp::Indirection,
    "+" => expr::UnaryOp::Positive,
    "-" => expr::UnaryOp::Negative,
    "~" => expr::UnaryOp::BitwiseNot,
    "!" => expr::UnaryOp::LogicalNot,
};

CastExpression: Box<expr::Expression> = {
    UnaryExpression,
    "(" TypeName ")" CastExpression
        => expr::CastExr::new(<>),
};

MultiplicativeExpression: Box<expr::Expression> = {
    CastExpression,
    MultiplicativeExpression "*" CastExpression
        => expr::TwoOperandsExpr::new_mul(<>),
    MultiplicativeExpression "/" CastExpression
        => expr::TwoOperandsExpr::new_div(<>),
    MultiplicativeExpression "%" CastExpression
        => expr::TwoOperandsExpr::new_rem(<>),
};

AdditiveExpression: Box<expr::Expression> = {
    MultiplicativeExpression,
    AdditiveExpression "+" MultiplicativeExpression
        => expr::TwoOperandsExpr::new_add(<>),
    AdditiveExpression "-" MultiplicativeExpression
        => expr::TwoOperandsExpr::new_sub(<>),
};

ShiftExpression: Box<expr::Expression> = {
    AdditiveExpression,
    ShiftExpression "<<" AdditiveExpression
        => expr::TwoOperandsExpr::new_left_shift(<>),
    ShiftExpression ">>" AdditiveExpression
        => expr::TwoOperandsExpr::new_right_shift(<>),
};

RelationalExpression: Box<expr::Expression> = {
    ShiftExpression,
    RelationalExpression "<" ShiftExpression
        => expr::TwoOperandsExpr::new_le(<>),
    RelationalExpression ">" ShiftExpression 
        => expr::TwoOperandsExpr::new_ge(<>),
    RelationalExpression "<=" ShiftExpression
        => expr::TwoOperandsExpr::new_ge_or_eq(<>),
    RelationalExpression ">=" ShiftExpression
        => expr::TwoOperandsExpr::new_ge_or_eq(<>),
};

EqualityExpression: Box<expr::Expression> = {
    RelationalExpression,
    EqualityExpression "==" RelationalExpression
        => expr::TwoOperandsExpr::new_eq(),
    EqualityExpression "!=" RelationalExpression 
        => expr::TwoOperandsExpr::new_not_eq(),
};

AndExpression: Box<expr::Expression> = {
    EqualityExpression
    AndExpression "&" EqualityExpression 
        => expr::TwoOperandsExpr::new_bw_and(<>),
}

ExclusiveOrExpression: Box<expr::Expression> = {
    AndExpression,
    ExclusiveOrExpression "^" AndExpression 
        => expr::TwoOperandsExpr::new_bw_xor(<>),
};

InclusiveOrExpression: Box<expr::Expression> = {
    ExclusiveOrExpression,
    InclusiveOrExpression "|" ExclusiveOrExpression 
        => expr::TwoOperandsExpr::new_bw_or(<>),
};

LogicalAndExpression: Box<expr::Expression> = {
    InclusiveOrExpression,
    LogicalAndExpression "&&" InclusiveOrExpression 
        => expr::TwoOperandsExpr::new_logical_and(<>),
};

LogicalOrExpression: Box<expr::Expression> = {
    LogicalAndExpression,
    LogicalOrExpression "||" LogicalAndExpression
        => expr::TwoOperandsExpr::new_logical_or(<>),
};

ConditionalExpression: Box<expr::Expression> = {
    LogicalOrExpression,
    LogicalOrExpression "?" Expression ":" ConditionalExpression
        => Box::new(expr::Expression::Ternary(expr::Ternary{})),
};

AssignmentExpression: Box<expr::Expression> = {
    ConditionalExpression,
    <lhs: UnaryExpression> <op: AssignmentOperator> <rhs: AssignmentExpression>
        => Box::new(expr::Expression::TwoOperands(expr::TwoOperandsExpr{lhs, op, rhs})),
};

AssignmentOperator: expr::BinOp = {
    "=" => expr::BinOp::Assign,
    "*=" => expr::BinOp::MulAssign,
    "/=" => expr::BinOp::DivAssign,
    "%=" => expr::BinOp::ModAssign,
    "+=" => expr::BinOp::AddAssign,
    "-=" => expr::BinOp::SubAssign,
    "<<=" => expr::BinOp::BwLShAssign,
    ">>=" => expr::BinOp::BwRShAssign,
    "&=" => expr::BinOp::BwAndAssign,
    "^=" => expr::BinOp::BwXorAssign,
    "|=" => expr::BinOp::BwOrAssign,
};

Expression: Box<expr::Expression> = {
    AssignmentExpression ("," AssignmentExpression)* 
        => expr::TwoOperandsExpr::new_assign(<>),
};

ConstantExpression: Box<expr::Expression> = ConditionalExpression;

//////////////////////////////////////////////////
/// Statements ///////////////////////////////////
//////////////////////////////////////////////////

Statement: Box<stmt::Statement> = {
    LabeledStatement
    CompoundStatement,
    ExpressionStatement,
    SelectionStatement,
    IterationStatement,
    JumpStatement,
};

CompoundStatement: Box<stmt::Statement> = {
    "{" BlockItem* "}" 
        => expr::CompoundLiteral::new(<>),
};  

BlockItem: stmt::BlockItem = {
    <d: Declaration> => stmt::BlockItem::Declaration(d),
    <s: Statement> => stmt::BlockItem::Statement(s),
};

ExpressionStatement: stmt::Statement = {
    Expression ";" => stmt::Statement::new_,
};

LabeledStatement: stmt::Statement = {
    <label: Identifier> ":" <marked: Statement>
        => Box::new(stmt::Statement::Labeled(stmt::Labeled{label, marked})),
    "case" <constant: ConstantExpression> ":" <body: Statement> 
        => Box::new(stmt::Statement::Case(stmt::Case{constant, body})),
    "default" ":" <body: Statement> 
        => Box::new(stmt::Statement::Default(stmt::Default{body})),
};

SelectionStatement: stmt::Statement = {
    "if" "(" <pred: Expression> ")" <on_success: Statement> <on_failure: ("else" Statement)?> 
        => {
            if on_failure.is_some() {
                return stmt::Statement::IfElse(stmt::IfStmt{predicate: pred, first_stmt: on_success, second_stmt: on_failure});
            } else {
                return stmt::Statement::If(stmt::IfStmt{predicate: pred, first_stmt: on_success});
            }
        },  
    "switch" "(" Expression ")" Statement 
        => stmt::Statement::new_switch(<>),
};

ForInitializerPart: stmt::ForInit = {
    Expression ";" => stmt::ForInit::Expression(<>),
    Declaration => stmt::ForInit::Declaration(<>),
};

IterationStatement: stmt::Statement = {
    "while" "(" Expression ")" Statement 
        => stmt::Statement::new_while(<>),
    "do" Statement "while" "(" Expression ")" ";"
        => stmt::Statement::new_do_while(<>),
    "for" "(" ForInitializerPart? Expression? ";" Expression? ")" Statement
        => stmt::Statement::new_for(<>),
};

JumpStatement: stmt::Statement = {
    "goto" Identifier ";" 
        => stmt::Statement::new_goto(<>),
    "continue" ";" 
        => stmt::Statement::new_continue(),
    "break" ";" 
        => stmt::Statement::new_break(),
    "return" Expression ";" 
        => stmt::Statement::new_return(<>),
};
